package byteback.syntax.scene.type.declaration.member.method.body.transformer;

import byteback.syntax.Vimp;
import byteback.syntax.scene.type.declaration.member.method.body.context.BodyContext;
import soot.*;
import soot.javaToJimple.DefaultLocalGenerator;
import soot.jimple.Jimple;
import soot.jimple.NewExpr;
import soot.jimple.SpecialInvokeExpr;
import soot.util.Chain;
import soot.util.HashChain;

import java.util.Collections;
import java.util.Iterator;
import java.util.Optional;

/**
 * Transformer adding explicit checks for implicit exceptional behavior. The resulting effect of this transformation is:
 * If before executing a statement certain conditions for exceptional behavior hold, throw an exception.
 *
 * @author paganma
 */
public abstract class CheckTransformer extends BodyTransformer {

    public final Scene scene;

    public final String exceptionClassName;

    /**
     * Constructs a new {@link CheckTransformer}
     *
     * @param scene              The scene used to fetch the exception type.
     * @param exceptionClassName The name of the exception type.
     */
    public CheckTransformer(final Scene scene, final String exceptionClassName) {
        this.scene = scene;
        this.exceptionClassName = exceptionClassName;
    }

    /**
     * Creates a check for a unit.
     *
     * @param unit The unit to be checked.
     * @return The expression representing the check for the unit if such check is required.
     */
    protected abstract Optional<Value> makeUnitCheck(final Unit unit);

    /**
     * Getter for the type of the exception thrown if the check fails.
     *
     * @return The type of the exception thrown if the check fails.
     */
    public RefType getExceptionType() {
        assert scene.doneResolving();

        return scene.getRefType(exceptionClassName);
    }

    /**
     * Creates a constructor invocation for the exception type (as defined by {@link #getExceptionType}).
     *
     * @param exceptionClass The exception class.
     * @param local          The local to which the exception is assigned.
     * @return The constructor invocation initializing {@param local} with the constructor for {@param exceptionClass}.
     */
    protected SpecialInvokeExpr makeExceptionConstructionExpr(final SootClass exceptionClass, final Local local) {
        final SootMethodRef exceptionConstructorRef = scene.makeConstructorRef(
                exceptionClass,
                Collections.emptyList()
        );
        return Jimple.v().newSpecialInvokeExpr(
                local,
                exceptionConstructorRef,
                Collections.emptyList()
        );
    }

    /**
     * Creates the units for throwing the exceptions generated by the checks.
     *
     * @param localGenerator The generator used to create the local used for assigning the exception.
     * @return The units throwing the exception.
     */
    private Chain<Unit> makeThrowUnits(final LocalGenerator localGenerator) {
        final Chain<Unit> units = new HashChain<>();

        // Create new local $e for containing the exception
        final RefType exceptionType = getExceptionType();
        final Local local = localGenerator.generateLocal(exceptionType);

        // $e = new Exception;
        final NewExpr newExceptionExpr = Jimple.v().newNewExpr(exceptionType);
        final Unit assignNewExprUnit = Jimple.v().newAssignStmt(local, newExceptionExpr);
        units.addLast(assignNewExprUnit);

        // specialinvoke Exception($e);
        final SootClass exceptionClass = exceptionType.getSootClass();
        final SpecialInvokeExpr exceptionConstructionExpr = makeExceptionConstructionExpr(exceptionClass, local);
        final Unit exceptionConstructionUnit = Jimple.v().newInvokeStmt(exceptionConstructionExpr);
        units.addLast(exceptionConstructionUnit);

        // throw $e;
        final Unit throwUnit = Jimple.v().newThrowStmt(local);
        units.addLast(throwUnit);


        return units;
    }

    @Override
    public void transformBody(final BodyContext bodyContext) {
        final Body body = bodyContext.getBody();
        final Chain<Unit> units = body.getUnits();
        final Iterator<Unit> unitIterator = units.snapshotIterator();
        final LocalGenerator localGenerator = new DefaultLocalGenerator(body);

        while (unitIterator.hasNext()) {
            final Unit unit = unitIterator.next();
            final Optional<Value> unitCheckOption = makeUnitCheck(unit);

            if (unitCheckOption.isPresent()) {
                final Value unitCheck = unitCheckOption.get();
                final Chain<Unit> throwUnits = makeThrowUnits(localGenerator);
                units.insertBefore(throwUnits, unit);
                final Unit checkStmt = Vimp.v().newIfStmt(unitCheck, unit);
                units.insertBefore(checkStmt, throwUnits.getFirst());
            }
        }
    }

}
