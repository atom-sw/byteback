package byteback.syntax.scene.type.declaration.member.method.body.transformer;

import byteback.syntax.scene.type.declaration.member.method.body.Vimp;
import soot.*;
import soot.javaToJimple.DefaultLocalGenerator;
import soot.jimple.Jimple;
import soot.jimple.NewExpr;
import soot.jimple.SpecialInvokeExpr;
import soot.util.Chain;
import soot.util.HashChain;

import java.util.Collections;
import java.util.Iterator;
import java.util.Optional;

/**
 * Transformer adding explicit checks for implicit exceptional
 * behavior. The resulting effect of this transformation is: If before
 * executing a statement certain conditions for exceptional behavior
 * hold, throw an exception.
 *
 * @author paganma
 */
public abstract class CheckTransformer extends BodyTransformer {

	private final Scene scene;

	private final String exceptionClassName;

	/**
	 * Constructs a new {@link CheckTransformer}
	 *
	 * @param scene              The scene used to fetch the exception type.
	 * @param exceptionClassName The name of the exception type.
	 */
	public CheckTransformer(final Scene scene, final String exceptionClassName) {
		this.scene = scene;
		this.exceptionClassName = exceptionClassName;
	}

	public Scene getScene() {
		return scene;
	}

	public String getExceptionClassName() {
		return exceptionClassName;
	}

	/**
	 * Creates a check for a unit.
	 *
	 * @param unit The unit to be checked.
	 * @return The expression representing the check for the unit if such check is
	 *         required.
	 */
	protected abstract Optional<Value> makeUnitCheck(final Unit unit);

	/**
	 * Getter for the type of the exception thrown if the check fails.
	 *
	 * @return The type of the exception thrown if the check fails.
	 */
	public RefType getExceptionType() {
		assert scene.doneResolving();

		return scene.getRefType(exceptionClassName);
	}

	/**
	 * Creates a constructor invocation for the exception type (as
	 * defined by {@link #getExceptionType}).
	 *
	 * @param exceptionClass The exception class.
	 * @param local          The local to which the exception is assigned.
	 * @return The constructor invocation initializing {@param local}
	 *         with the constructor for {@param exceptionClass}.
	 */
	protected SpecialInvokeExpr makeExceptionConstructionExpr(final SootClass exceptionClass, final Local local) {
		final SootMethodRef exceptionConstructorRef = scene.makeConstructorRef(
				exceptionClass,
				Collections.emptyList());
		return Jimple.v().newSpecialInvokeExpr(
				local,
				exceptionConstructorRef,
				Collections.emptyList());
	}

	/**
	 * Creates the units for throwing the exceptions generated by the checks.
	 *
	 * @param localGenerator The generator used to create the local used
	 *                       for assigning the exception.
	 * @return The units throwing the exception.
	 */
	protected Chain<Unit> makeHandlerUnits(final LocalGenerator localGenerator) {
		final Chain<Unit> units = new HashChain<>();

		// Create new local $e for containing the exception
		final RefType exceptionType = getExceptionType();
		final Local local = localGenerator.generateLocal(exceptionType);

		// $e = new Exception;
		final NewExpr newExceptionExpr = Jimple.v().newNewExpr(exceptionType);
		final Unit assignNewExprUnit = Jimple.v().newAssignStmt(local, newExceptionExpr);
		units.addLast(assignNewExprUnit);

		// specialinvoke Exception($e);
		final SootClass exceptionClass = exceptionType.getSootClass();
		final SpecialInvokeExpr exceptionConstructionExpr = makeExceptionConstructionExpr(exceptionClass, local);
		final Unit exceptionConstructionUnit = Jimple.v().newInvokeStmt(exceptionConstructionExpr);
		units.addLast(exceptionConstructionUnit);

		// throw $e;
		final Unit throwUnit = Jimple.v().newThrowStmt(local);
		units.addLast(throwUnit);

		return units;
	}

	@Override
	public void transformBody(final SootMethod sootMethod, final Body body) {
		final PatchingChain<Unit> units = body.getUnits();
		final Iterator<Unit> unitIterator = units.snapshotIterator();
		final LocalGenerator localGenerator = new DefaultLocalGenerator(body);

		while (unitIterator.hasNext()) {
			final Unit unit = unitIterator.next();
			makeUnitCheck(unit).ifPresent((unitCheck) -> {
				final Chain<Unit> throwUnits = makeHandlerUnits(localGenerator);
				units.insertBefore(throwUnits, unit);
				final Unit checkStmt = Vimp.v().newIfStmt(Vimp.v().nest(unitCheck), unit);
				units.insertBefore(checkStmt, throwUnits.getFirst());
			});
		}
	}

}
